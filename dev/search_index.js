var documenterSearchIndex = {"docs":
[{"location":"ind/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"ind/","page":"Index","title":"Index","text":"Modules = [KeplerGL]","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Point-Layer:-Shipwrecks-from-DARMC","page":"Examples","title":"Point Layer: Shipwrecks from DARMC","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first example is to plot the location and date of a number of shipwrecks around Europe. The data come from the Digital Atlas of Roman and Medieval Civilizations at Harvard.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We download the data using Downloads and convert it to a DataFrame using CSV.jl:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using KeplerGL \nusing CSV, DataFrames\nusing ColorBrewer\nusing Downloads\n\nshipwrecks_url = \"https://docs.google.com/spreadsheets/d/11fk5YeQ4eFOnYSBNpUdHp4TP42gJ7wY5/gviz/tq?tqx=out:csv&sheet=GeoDatabase\"\n\nhttp_response = Downloads.download(shipwrecks_url);\ndf = CSV.File(http_response) |> DataFrame","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We drop all shipwrecks for which we don't have geocoordinates:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"dropmissing!(df, [:Latitude, :Longitude])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We now create the KeplerGLMap. We want to choose our camera position freely and therefore choose center_map=false. We also need a Mapbox token, which can be obtained by creating and account on Mapbox.com. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"token = \"<enter your token here>\" \nm = KeplerGL.KeplerGLMap(token, center_map=false, read_only=true)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We then add the point layer to the map. We color the points depending on the End_Date and choose the radius to depend on Width, noting that this means that many shipwrecks with missing information will get dropped:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"KeplerGL.add_point_layer!(m, df, :Latitude, :Longitude,\n    color_range=parse.(Colorant, [\"#00939C\",\"#5DBABF\",\"#BAE1E2\",\"#F8C0AA\",\"#DD7755\",\"#C22E00\"]),\n    color_field=:End_Date,color_scale=\"quantize\",opacity=0.5,\n    radius_field = :Width, radius_fixed = false, radius_range = [10,50])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, we add some aesthetics to the map. We choose Mapbox's dark theme, disable the labels on the map, and remove the legend.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# disable map legend\nm.window[:map_legend_show]=false\n# disable the labels on the map\nm.config[:config][:mapStyle][:visibleLayerGroups][:label]=false\n# use a dark basemap\nm.config[:config][:mapStyle][:styleType]=\"dark\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then we set the zoom and camera position:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"m.config[:config][:mapState][:zoom] = 3.2109865005249962\nm.config[:config][:mapState][:latitude] = 49.989862149983416\nm.config[:config][:mapState][:longitude] = 12.118123312294815","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we're ready to render and export the map to a PNG.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"w = KeplerGL.render(m)\nKeplerGL.export_image(w, \"shipwrecks.png\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Point example: shipwrecks)","category":"page"},{"location":"examples/#Hexbin:-the-Trees-of-Paris","page":"Examples","title":"Hexbin: the Trees of Paris","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Our objective here is to create a hexagon plot that shows the density and average height of trees in Paris. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, we load a couple of packages that we need:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using KeplerGL \nusing CSV, DataFrames\nusing ColorBrewer","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Our data come from the Direction des Espaces Verts et de l'Environnement of the City of Paris (more info here). We download the data using the Downloads package (which is part of Julia's stdlib since Julia 1.6) and use CSV.jl to convert it into a DataFrame.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Downloads\n\ntrees_url = \"https://opendata.paris.fr/api/explore/v2.1/catalog/datasets/les-arbres/exports/csv?lang=fr&timezone=Europe%2FBerlin&use_labels=true&delimiter=%3B\"\nhttp_response = Downloads.download(trees_url);\n\ndf = CSV.File(http_response) |> DataFrame","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The geo_point_2d field contains a String with latitude and longitude separated by a comma. Again let's use CSV.jl to separate out the two:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"v= map(x -> \"$x\\n\", df.geo_point_2d)\ndf2 = CSV.File(IOBuffer(string(\"lat,lon\\n\",string(v...)))) |> DataFrame\ndf.Latitude = df2.lat \ndf.Longitude = df2.lon","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we have the data ready to be plotted. First, create the KeplerGLMap. We want to choose our camera perspective freely, so we set center_map=false. We also need to have our Mapbox token ready:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"token = \"<enter your token here>\" \n# `read_only=true` removes the button to add layers etc\nm = KeplerGL.KeplerGLMap(token, center_map=false, read_only=true)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We want to have a nice plot without annoying buttons on the right, so we turn on 3d but turn off all buttons:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Switch on 3d but remove the button\nm.window[:toggle_3d_show] = false\nm.window[:toggle_3d_active] = true\n# Don't show the legend or the button for it\nm.window[:map_legend_show] = false\nm.window[:map_legend_active] = false\n# Remove button for layers\nm.window[:visible_layers_show] = false\nm.window[:visible_layers_active] = false","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we can create the hexbin layer. We want darker colors for a higher density of trees, and the height of the columns depending on the average height of the trees.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"KeplerGL.add_hexagon_layer!(m, df, :Latitude, :Longitude,\n    opacity = 0.5,\n    radius = 0.2, color_range = ColorBrewer.palette(\"BuPu\",6), color_aggregation = \"average\", coverage = 0.95,\n    height_field = Symbol(\"HAUTEUR (m)\"), height_scale = \"linear\" , height_range=[0,1000], enable_3d=true)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, we set the camera position and angle. A nice way to get the right values is to first create the map interactively with Kepler.gl and then read off the map config values from the \"export map\" -> \"export as JSON\" menu.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"m.config[:config][:mapState][:latitude] = 48.85830271617524\nm.config[:config][:mapState][:longitude]= 2.338470433888891\nm.config[:config][:mapState][:zoom] = 11.364401854866383\nm.config[:config][:mapState][:pitch] = 30.121874231314532\nm.config[:config][:mapState][:dragRotate] = true","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we're ready to render the map. We'll also export the image as a PNG file. Ideally, run the export function immediately after the render, otherwise there are sometimes error messages showing up.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"w = KeplerGL.render(m)\n\n# Export the image\nKeplerGL.export_image(w, \"trees.png\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Hexbin example: trees of Paris)","category":"page"},{"location":"layers/#Layers","page":"Layers","title":"Layers","text":"","category":"section"},{"location":"layers/","page":"Layers","title":"Layers","text":"Pages=[\"layers.md\"]\nDepth = 3","category":"page"},{"location":"layers/#Point-Layers","page":"Layers","title":"Point Layers","text":"","category":"section"},{"location":"layers/","page":"Layers","title":"Layers","text":"KeplerGL.add_point_layer!","category":"page"},{"location":"layers/#KeplerGL.add_point_layer!","page":"Layers","title":"KeplerGL.add_point_layer!","text":"add_point_layer!(m, table, latitude::Symbol, longitude::Symbol;\n    color = colorant\"#762A83\",\n    color_field::Symbol = :null,\n    color_range = [colorant\"#762A83\",colorant\"#AF8DC3\",colorant\"#E7D4E8\",colorant\"#D9F0D3\",colorant\"#7FBF7B\",colorant\"#1B7837\"],\n    color_scale = \"quantize\",\n    highlight_color = colorant\"#762A83\",\n    altitude::Symbol = :null,\n    radius = 10.0,\n    radius_fixed = true,\n    radius_field::Symbol = :null,\n    radius_range = [5.0, 15.0],\n    radius_scale = \"sqrt\",    \n    filled = true,\n    opacity = 1.0,\n    outline = false,\n    outline_thickness = 2.0,\n    outline_color = colorant\"#000000\",\n    outline_color_field::Symbol = :null,\n    outline_color_range = [colorant\"#FFFFFF\", colorant\"#000000\"],\n    outline_color_scale = \"quantile\")\n\nAdds a point layer to the map m, drawing data from table.\n\nRequired Arguments\n\nm::KeplerGLMap: the map that the layer should be added to\ntable: a Tables.jl-compatible table that contains the data to draw from \nlatitude::Symbol: name of the column of table that contains the latitude of the points\nlongitude::Symbol: name of the column of table that contains the longitude of the points\n\nOptional Arguments\n\nid = randstring(7): the string id of the layer\ncolor = colorant\"#762A83\": a Colors.jl-compatible color that the points should have (if fixed)\ncolor_field::Symbol = :null: the name of the column of table that should be used to color the points\ncolor_range: a vector of Colors.jl-compatible colors. Use colorant\"xyz\" to generate.\ncolor_scale = \"quantize\": either \"quantize\" or \"quantile\" depending on whether values or quantiles should be used for the color.\nhighlight_color = colorant\"#762A83\": highlight color.\naltitude::Symbol = :null: the name of the column of table that should be used for the altitude of the points\nradius = 10.0: fixed radius value of the points on the map\nradius_fixed = true: whether the radius should be fixed or depend on radius_field \nradius_field::Symbol = :null: the name of the column of table that should be used for the radius of the points\nradius_range = [5.0, 15.0]: range of the radii of the points\nradius_scale = \"sqrt\": how to map radius_field into the radius    \nfilled = true: whether the point markers should be filled or not\nopacity = 1.0: opacity of the points, between 0.0 and 1.0\noutline = false: whether the point markers should have an outline\noutline_thickness = 2.0: thickness of the outline\noutline_color = colorant\"#000000\": a Colors.jl-compatible color that the point outlines should have (if fixed)\noutline_color_field::Symbol = :null: the name of the column of table that should be used to color the point outlines\noutline_color_range = [colorant\"#FFFFFF\", colorant\"#000000\"]: a vector of Colors.jl-compatible colors for the outlines. Use colorant\"xyz\" to generate.\noutline_color_scale = \"quantile\": either \"quantize\" or \"quantile\" depending on whether values or quantiles should be used for the outline color\n\nExamples\n\nm = KeplerGL.KeplerGLMap(token)\ndf = CSV.read(\"assets/example_data/data.csv\", DataFrame)\nKeplerGL.add_point_layer!(m, df, :Latitude, :Longitude,\n    color = colorant\"rgb(23,184,190)\", color_field = :Magnitude, color_scale = \"quantize\", \n    color_range = ColorBrewer.palette(\"PRGn\", 6),\n    radius_field = :Magnitude, radius_scale = \"sqrt\", radius_range = [4.2, 96.2], radius_fixed = false,\n    filled = true, opacity = 0.39, outline = false);\n\n\n\n\n\n","category":"function"},{"location":"layers/#Polygon-Layers","page":"Layers","title":"Polygon Layers","text":"","category":"section"},{"location":"layers/","page":"Layers","title":"Layers","text":"KeplerGL.add_polygon_layer!","category":"page"},{"location":"layers/#KeplerGL.add_polygon_layer!","page":"Layers","title":"KeplerGL.add_polygon_layer!","text":"add_polygon_layer!(m::KeplerGLMap, table, geojson::Symbol;\n    color = colorant\"#762A83\",\n    color_field::Symbol = :null,\n    color_range = [colorant\"#762A83\",colorant\"#AF8DC3\",colorant\"#E7D4E8\",colorant\"#D9F0D3\",colorant\"#7FBF7B\",colorant\"#1B7837\"],\n    color_scale = \"quantize\",\n    highlight_color = colorant\"#762A83\",\n    filled = true,\n    opacity = 1.0,\n    outline = false,\n    outline_opacity = 1.0,\n    outline_thickness = 2.0,\n    outline_color = colorant\"#000000\",\n    outline_color_field::Symbol = :null,\n    outline_color_range = [colorant\"#FFFFFF\", colorant\"#000000\"],\n    outline_color_scale = \"quantile\",\n    outline_width_field::Symbol = :null,\n    outline_width_scale = \"linear\",\n    height_field::Symbol = :null,\n    height_scale = \"linear\",\n    elevation_scale = 1.0,\n    enable_elevation_zoom_factor = true,\n    enable_3d = false)\n\nAdds a polygon layer to the map m, drawing data from table.\n\nRequired Arguments\n\nm::KeplerGLMap: the map that the layer should be added to\ntable: a Tables.jl-compatible table that contains the data to draw from \ngeojson::Symbo: name of the column of table that contains the feature in GeoJSON format\n\nOptional Arguments\n\nid = randstring(7): the string id of the layer\ncolor = colorant\"#762A83\": a Colors.jl-compatible color that the shapes should have (if fixed)\ncolor_field::Symbol = :null: the name of the column of table that should be used to color the shapes\ncolor_range: a vector of Colors.jl-compatible colors. Use colorant\"xyz\" to generate.\ncolor_scale = \"quantize\": either \"quantize\" or \"quantile\" depending on whether values or quantiles should be used for the color.\nhighlight_color = colorant\"#762A83\": highlight color.\nfilled = true: whether the polygon is filled or not.\nopacity = 1.0: opacity of the points, between 0.0 and 1.0\noutline = false: whether the point markers should have an outline\noutline_thickness = 2.0: thickness of the outline\noutline_color = colorant\"#000000\": a Colors.jl-compatible color that the point outlines should have (if fixed)\noutline_color_field::Symbol = :null: the name of the column of table that should be used to color the point outlines\noutline_color_range = [colorant\"#FFFFFF\", colorant\"#000000\"]: a vector of Colors.jl-compatible colors for the outlines. Use colorant\"xyz\" to generate.\noutline_color_scale = \"quantile\": either \"quantize\" or \"quantile\" depending on whether values or quantiles should be used for the outline color\noutline_width_field::Symbol = :null: name of the column of table that should be used to determine the width of the polygon outline\noutline_width_scale = \"linear\": how the values in outline_width_field should be converted into the with of the outline\nheight_field::Symbol = :null: name of the column of table that should be used to determine the height of the feature\nheight_scale = \"linear\": how height_field should be converted into the actual height \nelevation_scale = 1.0: scaling factor for the height\nenable_elevation_zoom_factor = true\nenable_3d = false: enable 3d on the layer  \n\nExamples\n\nm = KeplerGL.KeplerGLMap(token, center_map=false, read_only=true)\ndf = CSV.read(\"assets/example_data/counties-unemployment.csv\", DataFrame)\nKeplerGL.add_polygon_layer!(m, df, :_geojson ,\n    color = colorant\"red\", color_field = :unemployment_rate, color_range = ColorBrewer.palette(\"RdPu\", 9),\n    color_scale = \"quantile\", opacity = 0.8)\n\n\n\n\n\n","category":"function"},{"location":"layers/#Hexbin-Layers","page":"Layers","title":"Hexbin Layers","text":"","category":"section"},{"location":"layers/","page":"Layers","title":"Layers","text":"KeplerGL.add_hexagon_layer!","category":"page"},{"location":"layers/#KeplerGL.add_hexagon_layer!","page":"Layers","title":"KeplerGL.add_hexagon_layer!","text":"add_hexagon_layer!(m::KeplerGLMap, table, latitude::Symbol, longitude::Symbol;\n    color = colorant\"#762A83\",\n    color_field::Symbol = :null,\n    color_range = [colorant\"#762A83\",colorant\"#AF8DC3\",colorant\"#E7D4E8\",colorant\"#D9F0D3\",colorant\"#7FBF7B\",colorant\"#1B7837\"],\n    color_scale = \"quantile\",\n    color_aggregation = \"average\",\n    highlight_color = colorant\"#762A83\",\n    radius = 0.6,\n    coverage = 0.95,\n    resolution = 8,\n    opacity = 1.0,\n    height_field::Symbol = :null,\n    height_scale = \"sqrt\",\n    height_percentile = [0,100],\n    height_aggregation = \"average\",\n    elevation_percentile = [0,100],\n    elevation_scale = 5,\n    enable_elevation_zoom_factor = true,\n    enable_3d = false)\n\nAdds a hexbin layer to the map m, drawing data from table.\n\nRequired Arguments\n\nm::KeplerGLMap: the map that the layer should be added to\ntable: a Tables.jl-compatible table that contains the data to draw from \nlatitude::Symbol: name of the column of table that contains the latitude of the points to be aggregated into the hexbin\nlongitude::Symbol: name of the column of table that contains the longitude of the points to be aggregated into the hexbin\n\nOptional Arguments\n\nid = randstring(7): the string id of the layer\ncolor = colorant\"#762A83\": a Colors.jl-compatible color that the hexagons should have (if fixed)\ncolor_field::Symbol = :null: the name of the column of table that should be used to color the hexagons\ncolor_range: a vector of Colors.jl-compatible colors. Use colorant\"xyz\" to generate.\ncolor_scale = \"quantize\": either \"quantize\" or \"quantile\" depending on whether values or quantiles should be used for the color.\nhighlight_color = colorant\"#762A83\": highlight color.\nradius = 10.0: fixed radius value of the hexagons on the map\ncoverage = 0.95: fraction of the hexagon area that should be covered\nresolution = 8\nopacity = 1.0: opacity of the hexagons, between 0.0 and 1.0\nheight_field::Symbol = :null: name of the column of table that should be used to determine the height of the hexagons\nheight_scale = \"sqrt\": how height_field should be converted into the actual height \nheight_percentile = [0,100]:\nheight_aggregation = \"average\":\nheight_range = [0,500]: range of the height of columns\nelevation_percentile = [0,100]:\nelevation_scale = 5: scaling factor for the height\nenable_elevation_zoom_factor = true\nenable_3d = false: nable 3d on the layer  \n\nExamples\n\nm = KeplerGL.KeplerGLMap(token)\ndf = CSV.read(\"assets/example_data/data.csv\", DataFrame)\nKeplerGL.add_hexagon_layer!(m, df, :Latitude, :Longitude, opacity = 0.5, color_field = :Magnitude, color_scale = \"quantile\",\n    radius = 20.0, color_range = ColorBrewer.palette(\"BuPu\",6), color_aggregation = \"average\", coverage = 0.95,\n    height_field = :Magnitude )\n\n\n\n\n\n","category":"function"},{"location":"layers/#Line-Layers","page":"Layers","title":"Line Layers","text":"","category":"section"},{"location":"layers/","page":"Layers","title":"Layers","text":"KeplerGL.add_line_layer!","category":"page"},{"location":"layers/#KeplerGL.add_line_layer!","page":"Layers","title":"KeplerGL.add_line_layer!","text":"add_line_layer!(m::KeplerGLMap, table, latitude0::Symbol, longitude0::Symbol, \n    latitude1::Symbol, longitude1::Symbol;\n    color = colorant\"#762A83\",\n    color_field::Symbol = :null,\n    color_range = [colorant\"#762A83\",colorant\"#AF8DC3\",colorant\"#E7D4E8\",colorant\"#D9F0D3\",colorant\"#7FBF7B\",colorant\"#1B7837\"],\n    color_scale = \"quantize\",\n    highlight_color = colorant\"#762A83\",\n    altitude0::Symbol = :null,\n    altitude1::Symbol = :null,\n    size_field::Symbol = :null,\n    size_range = [1,10],\n    size_scale = \"linear\",\n    opacity = 1.0,\n    thickness = 2.0,\n    elevation_scale = 1)\n\nAdds a line layer to the map m, drawing data from table.\n\nRequired Arguments\n\nm::KeplerGLMap: the map that the layer should be added to\ntable: a Tables.jl-compatible table that contains the data to draw from \nlatitude0::Symbol: name of the column of table that contains the latitude of the origin of the line\nlongitude0::Symbol: name of the column of table that contains the longitude of the origin of the line\nlatitude1::Symbol: name of the column of table that contains the latitude of the endpoint of the line\nlongitude1::Symbol: name of the column of table that contains the longitude of the endpoint of the line\n\nOptional Arguments\n\nid = randstring(7): the string id of the layer\ncolor = colorant\"#762A83\": a Colors.jl-compatible color that the lines should have (if fixed)\ncolor_field::Symbol = :null: the name of the column of table that should be used to color the lines\ncolor_range = [colorant\"#762A83\",colorant\"#AF8DC3\",colorant\"#E7D4E8\",colorant\"#D9F0D3\",colorant\"#7FBF7B\",colorant\"#1B7837\"]: a vector of Colors.jl-compatible colors. Use colorant\"xyz\" to generate.\ncolor_scale = \"quantize\": either \"quantize\" or \"quantile\" depending on whether values or quantiles should be used for the color.\nhighlight_color = colorant\"#762A83\": highlight color.\naltitude0::Symbol = :null: altitude of the origin of the line.\naltitude1::Symbol = :null: altitude of the endpoint of the line.\nsize_field::Symbol = :null: name of the column of table that should be used for the line thickness\nsize_range = [1,10]: thickness range of the lines\nsize_scale = \"linear\": how size_field should be converted into the actual line thickness\nopacity = 1.0: opacity of the lines\nthickness = 2.0: line thickness, if constant\nelevation_scale = 1: scaling factor for the altitude.\n\nExamples\n\nm = KeplerGL.KeplerGLMap(token, center_map=false)\ndf = CSV.read(\"assets/example_data/data.csv\", DataFrame)\ndf.Latitude1 = df.Latitude .+ (rand(rng, Float64, length(df.Latitude)) .- 0.5)\ndf.Longitude1 = df.Longitude .+ 10.0 .* (rand(rng, Float64, length(df.Longitude)) .- 0.5) \nKeplerGL.add_line_layer!(m, df, :Latitude, :Longitude, :Latitude1, :Longitude1,\n    opacity = 0.5, color_field = :Magnitude, color_scale = \"quantile\",\n    color_range = ColorBrewer.palette(\"BuPu\",6), thickness = 3)\n\n\n\n\n\n","category":"function"},{"location":"layers/#Arc-Layers","page":"Layers","title":"Arc Layers","text":"","category":"section"},{"location":"layers/","page":"Layers","title":"Layers","text":"KeplerGL.add_arc_layer!","category":"page"},{"location":"layers/#KeplerGL.add_arc_layer!","page":"Layers","title":"KeplerGL.add_arc_layer!","text":"add_arc_layer!(m::KeplerGLMap, table, latitude0::Symbol, longitude0::Symbol, \n    latitude1::Symbol, longitude1::Symbol;\n    color = colorant\"#762A83\",\n    color_field::Symbol = :null,\n    color_range = [colorant\"#762A83\",colorant\"#AF8DC3\",colorant\"#E7D4E8\",colorant\"#D9F0D3\",colorant\"#7FBF7B\",colorant\"#1B7837\"],\n    color_scale = \"quantize\",\n    highlight_color = colorant\"#762A83\",\n    altitude0::Symbol = :null,\n    altitude1::Symbol = :null,\n    size_field::Symbol = :null,\n    size_range = [1,10],\n    size_scale = \"linear\",\n    opacity = 1.0,\n    thickness = 2.0,\n    elevation_scale = 1)\n\nAdds an arc layer to the map m, drawing data from table.\n\nRequired Arguments\n\nm::KeplerGLMap: the map that the layer should be added to\ntable: a Tables.jl-compatible table that contains the data to draw from \nlatitude0::Symbol: name of the column of table that contains the latitude of the origin of the line\nlongitude0::Symbol: name of the column of table that contains the longitude of the origin of the line\nlatitude1::Symbol: name of the column of table that contains the latitude of the endpoint of the line\nlongitude1::Symbol: name of the column of table that contains the longitude of the endpoint of the line\n\nOptional Arguments\n\nid = randstring(7): the string id of the layer\ncolor = colorant\"#762A83\": a Colors.jl-compatible color that the lines should have (if fixed)\ncolor_field::Symbol = :null: the name of the column of table that should be used to color the lines\ncolor_range = [colorant\"#762A83\",colorant\"#AF8DC3\",colorant\"#E7D4E8\",colorant\"#D9F0D3\",colorant\"#7FBF7B\",colorant\"#1B7837\"]: a vector of Colors.jl-compatible colors. Use colorant\"xyz\" to generate.\ncolor_scale = \"quantize\": either \"quantize\" or \"quantile\" depending on whether values or quantiles should be used for the color.\nhighlight_color = colorant\"#762A83\": highlight color.\naltitude0::Symbol = :null: altitude of the origin of the line.\naltitude1::Symbol = :null: altitude of the endpoint of the line.\nsize_field::Symbol = :null: name of the column of table that should be used for the line thickness\nsize_range = [1,10]: thickness range of the lines\nsize_scale = \"linear\": how size_field should be converted into the actual line thickness\nopacity = 1.0: opacity of the lines\nthickness = 2.0: line thickness, if constant\nelevation_scale = 1: scaling factor for the altitude.\n\nExamples\n\nm = KeplerGL.KeplerGLMap(token, center_map=false)\ndf = CSV.read(\"assets/example_data/data.csv\", DataFrame)\ndf.Latitude1 = df.Latitude .+ (rand(rng, Float64, length(df.Latitude)) .- 0.5)\ndf.Longitude1 = df.Longitude .+ 10.0 .* (rand(rng, Float64, length(df.Longitude)) .- 0.5) \nKeplerGL.add_arc_layer!(m, df, :Latitude, :Longitude, :Latitude1, :Longitude1,\n    opacity = 0.5, color_field = :Magnitude, color_scale = \"quantile\",\n    color_range = ColorBrewer.palette(\"BuPu\",6), thickness = 3)\n\n\n\n\n\n","category":"function"},{"location":"layers/#Grid-Layers","page":"Layers","title":"Grid Layers","text":"","category":"section"},{"location":"layers/","page":"Layers","title":"Layers","text":"KeplerGL.add_grid_layer!","category":"page"},{"location":"layers/#KeplerGL.add_grid_layer!","page":"Layers","title":"KeplerGL.add_grid_layer!","text":"add_grid_layer!(m::KeplerGLMap, table, latitude::Symbol, longitude::Symbol;\n    color = colorant\"#762A83\",\n    color_field::Symbol = :null,\n    color_range = [colorant\"#762A83\",colorant\"#AF8DC3\",colorant\"#E7D4E8\",colorant\"#D9F0D3\",colorant\"#7FBF7B\",colorant\"#1B7837\"],\n    color_scale = \"quantile\",\n    color_aggregation = \"average\",\n    highlight_color = colorant\"#762A83\",\n    radius = 0.6,\n    coverage = 0.95,\n    resolution = 8,\n    opacity = 1.0,\n    height_field::Symbol = :null,\n    height_scale = \"sqrt\",\n    height_percentile = [0,100],\n    height_aggregation = \"average\",\n    elevation_percentile = [0,100],\n    elevation_scale = 5,\n    enable_elevation_zoom_factor = true,\n    enable_3d = false)\n\nAdds a grid layer to the map m, drawing data from table.\n\nRequired Arguments\n\nm::KeplerGLMap: the map that the layer should be added to\ntable: a Tables.jl-compatible table that contains the data to draw from \nlatitude::Symbol: name of the column of table that contains the latitude of the points to be aggregated into the hexbin\nlongitude::Symbol: name of the column of table that contains the longitude of the points to be aggregated into the hexbin\n\nOptional Arguments\n\nid = randstring(7): the string id of the layer\ncolor = colorant\"#762A83\": a Colors.jl-compatible color that the hexagons should have (if fixed)\ncolor_field::Symbol = :null: the name of the column of table that should be used to color the hexagons\ncolor_range: a vector of Colors.jl-compatible colors. Use colorant\"xyz\" to generate.\ncolor_scale = \"quantize\": either \"quantize\" or \"quantile\" depending on whether values or quantiles should be used for the color.\nhighlight_color = colorant\"#762A83\": highlight color.\nradius = 10.0: fixed radius value of the hexagons on the map\ncoverage = 0.95: fraction of the hexagon area that should be covered\nresolution = 8\nopacity = 1.0: opacity of the hexagons, between 0.0 and 1.0\nheight_field::Symbol = :null: name of the column of table that should be used to determine the height of the hexagons\nheight_scale = \"sqrt\": how height_field should be converted into the actual height \nheight_percentile = [0,100]:\nheight_aggregation = \"average\":\nelevation_percentile = [0,100]:\nelevation_scale = 5: scaling factor for the height\nenable_elevation_zoom_factor = true\nenable_3d = false: nable 3d on the layer  \n\nExamples\n\nm = KeplerGL.KeplerGLMap(token)\ndf = CSV.read(\"assets/example_data/data.csv\", DataFrame)\nKeplerGL.add_grid_layer!(m, df, :Latitude, :Longitude, opacity = 0.5, color_field = :Magnitude, color_scale = \"quantile\",\n    radius = 20.0, color_range = ColorBrewer.palette(\"BuPu\",6), color_aggregation = \"average\", coverage = 0.95,\n    height_field = :Magnitude )\n\n\n\n\n\n","category":"function"},{"location":"layers/#Heatmap-Layers","page":"Layers","title":"Heatmap Layers","text":"","category":"section"},{"location":"layers/","page":"Layers","title":"Layers","text":"KeplerGL.add_heatmap_layer!","category":"page"},{"location":"layers/#KeplerGL.add_heatmap_layer!","page":"Layers","title":"KeplerGL.add_heatmap_layer!","text":"add_heatmap_layer!(m::KeplerGLMap, table, latitude::Symbol, longitude::Symbol;\n    color = colorant\"#762A83\",\n    color_range = [colorant\"#762A83\",colorant\"#AF8DC3\",colorant\"#E7D4E8\",colorant\"#D9F0D3\",colorant\"#7FBF7B\",colorant\"#1B7837\"],\n    weight_field::Symbol = :null,\n    weight_scale = \"linear\",    \n    highlight_color = colorant\"#762A83\",\n    radius = 0.6,\n    opacity = 1.0)\n\nAdds a heatmap layer to the map m, drawing data from table.\n\nRequired Arguments\n\nm::KeplerGLMap: the map that the layer should be added to\ntable: a Tables.jl-compatible table that contains the data to draw from \nlatitude::Symbol: name of the column of table that contains the latitude of the points to be aggregated into the hexbin\nlongitude::Symbol: name of the column of table that contains the longitude of the points to be aggregated into the hexbin\n\nOptional Arguments\n\nid = randstring(7): the string id of the layer\ncolor = colorant\"#762A83\": a Colors.jl-compatible color that the hexagons should have (if fixed)\ncolor_range: a vector of Colors.jl-compatible colors. Use colorant\"xyz\" to generate.\nweight_field::Symbol = :null: the name of the column of table that should be used to weigh the heatmap\nweight_scale = \"linear\": how the weight_field should be translated into weights\nhighlight_color = colorant\"#762A83\": highlight color.\nradius = 10.0: kernel width of the heatmap\nopacity = 1.0: opacity of the layer, between 0.0 and 1.0\n\nExamples\n\nm = KeplerGL.KeplerGLMap(token)\ndf = CSV.read(\"assets/example_data/data.csv\", DataFrame)\nKeplerGL.add_heatmap_layer!(m, df, :Latitude, :Longitude, opacity = 0.5, weight_field = :Magnitude, weight_scale = \"linear\",\n    radius = 20.0, color_range = ColorBrewer.palette(\"BuPu\",6) )\n\n\n\n\n\n","category":"function"},{"location":"layers/#Cluster-Layers","page":"Layers","title":"Cluster Layers","text":"","category":"section"},{"location":"layers/","page":"Layers","title":"Layers","text":"KeplerGL.add_cluster_layer!","category":"page"},{"location":"layers/#KeplerGL.add_cluster_layer!","page":"Layers","title":"KeplerGL.add_cluster_layer!","text":"add_cluster_layer!(m::KeplerGLMap, table, latitude::Symbol, longitude::Symbol;\n    color = colorant\"#762A83\",\n    color_range = [colorant\"#762A83\",colorant\"#AF8DC3\",colorant\"#E7D4E8\",colorant\"#D9F0D3\",colorant\"#7FBF7B\",colorant\"#1B7837\"], \n    highlight_color = colorant\"#762A83\",\n    radius_range = [1,40],\n    cluster_radius = 20,\n    color_aggregation = \"count\",\n    color_field::Symbol = :null,\n    color_scale = \"quantize\",\n    opacity = 1.0)\n\nAdds a cluster layer to the map m, drawing data from table.\n\nRequired Arguments\n\nm::KeplerGLMap: the map that the layer should be added to\ntable: a Tables.jl-compatible table that contains the data to draw from \nlatitude::Symbol: name of the column of table that contains the latitude of the points to be aggregated into the hexbin\nlongitude::Symbol: name of the column of table that contains the longitude of the points to be aggregated into the hexbin\n\nOptional Arguments\n\nid = randstring(7): the string id of the layer\ncolor = colorant\"#762A83\": a Colors.jl-compatible color that the hexagons should have (if fixed)\ncolor_range: a vector of Colors.jl-compatible colors. Use colorant\"xyz\" to generate.\ncolor_field::Symbol = :null: the name of the column of table that should be used to color the cluster points\ncolor_scale = \"quantize\": either \"quantize\" or \"quantile\" depending on whether values or quantiles should be used for the color.\nhighlight_color = colorant\"#762A83\": highlight color.\nradius_range = [1,40]: range for the point radii\ncluster_radius = 20: radius for the clustering\ncolor_aggregation = \"count\": how to aggregate the color\nopacity = 1.0: opacity of the layer, between 0.0 and 1.0\n\nExamples\n\nm = KeplerGL.KeplerGLMap(token)\ndf = CSV.read(\"assets/example_data/data.csv\", DataFrame)\nKeplerGL.add_cluster_layer!(m, df, :Latitude, :Longitude, opacity = 0.5, color_field = :Magnitude, color_scale = \"quantile\",\n    radius_range = [1,40], cluster_radius = 20, color_range = ColorBrewer.palette(\"BuPu\",6), color_aggregation = \"count\" )\n\n\n\n\n\n","category":"function"},{"location":"reference/#Type-and-Function-Reference","page":"Type & Function Reference","title":"Type and Function Reference","text":"","category":"section"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"Pages=[\"reference.md\"]\nDepth = 3","category":"page"},{"location":"reference/#KeplerGLMap-and-rendering","page":"Type & Function Reference","title":"KeplerGLMap and rendering","text":"","category":"section"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.KeplerGLMap","category":"page"},{"location":"reference/#KeplerGL.KeplerGLMap","page":"Type & Function Reference","title":"KeplerGL.KeplerGLMap","text":"mutable struct KeplerGLMap \n    datasets::Vector{AbstractKeplerGLData}\n    config::Dict{Symbol, Any}\n    info::Dict{Symbol, Any}\n    window::Dict{Symbol, Any}\nend\n\nType that contains all the information to render a map.  config and info are of the same structure as the map JSON  serialization that Kepler.gl uses internally. datasets are instances of AbstractKeplerGLData that contain the data that the layers draw from.  window is additional information not used by Kepler.gl that contains information on window size, whether the map should be centered, and so on. \n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.render","category":"page"},{"location":"reference/#KeplerGL.render","page":"Type & Function Reference","title":"KeplerGL.render","text":"render(map::KeplerGLMap)\n\nRenders a KeplerGLMap in a new Blink.jl window and returns this window.\n\nRequired Arguments\n\nm::KeplerGLMap: the map that should be rendered\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.get_html","category":"page"},{"location":"reference/#KeplerGL.get_html","page":"Type & Function Reference","title":"KeplerGL.get_html","text":"get_html(m::KeplerGLMap)\n\nGets the html + js code to render the map in Blink\n\nRequired Arguments\n\nm::KeplerGLMap: the map to get the HTML code for.\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.make_dispatch_code","category":"page"},{"location":"reference/#KeplerGL.make_dispatch_code","page":"Type & Function Reference","title":"KeplerGL.make_dispatch_code","text":"make_dispatch_code(m::KeplerGLMap)\n\nThis function makes the dispatch code for m. It is called by render()  but is sometimes also useful to call directly for debugging purposes\n\nRequired Arguments\n\nm::KeplerGLMap: the map of which the dispatch code should be returned.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Loading-and-saving/exporting","page":"Type & Function Reference","title":"Loading and saving/exporting","text":"","category":"section"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.load_map_from_json","category":"page"},{"location":"reference/#KeplerGL.load_map_from_json","page":"Type & Function Reference","title":"KeplerGL.load_map_from_json","text":"load_map_from_json(token::String, json_map_file::String)\n\nReturns a KeplerGLMap whose data and config has been loaded from json_map_file.\n\nRequired Arguments\n\ntoken::String: mapbox token to use with the map.\njson_map_file::String: the path to the Kepler.gl map JSON file which should be loaded.\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.load_map_from_json!","category":"page"},{"location":"reference/#KeplerGL.load_map_from_json!","page":"Type & Function Reference","title":"KeplerGL.load_map_from_json!","text":"load_map_from_json!(m::KeplerGLMap, json_map_file::String)\n\nLoads a kepler.gl map file from json_map_file into the map m. Overwrites any existing map config and datasets.\n\nRequired Arguments\n\nm::KeplerGLMap: the map to which the config and data should be applied.\njson_map_file::String: the path to the kepler.gl JSON map file.\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.load_config_from_json!","category":"page"},{"location":"reference/#KeplerGL.load_config_from_json!","page":"Type & Function Reference","title":"KeplerGL.load_config_from_json!","text":"load_config_from_json!(m::KeplerGLMap, json_map_file::String)\n\nLoads the config from a json file json_map_file and applies it to the map m.\n\nRequired Arguments\n\nm::KeplerGLMap: the map to which the config should be applied.\njson_map_file::String: the path to the JSON file from which the config should be loaded.\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.get_json","category":"page"},{"location":"reference/#KeplerGL.get_json","page":"Type & Function Reference","title":"KeplerGL.get_json","text":"get_json(m::KeplerGLMap)\n\nReturns the map in JSON format, which is also the format which Kepler.gl uses  intrinsically to save map files.\n\nRequired Arguments\n\nm::KeplerGLMap: the map of which the JSON code should be returned.\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.export_image","category":"page"},{"location":"reference/#KeplerGL.export_image","page":"Type & Function Reference","title":"KeplerGL.export_image","text":"export_image(window,filename; \n    width = 1000, height = 800,\n    imageDataUri = \"data:image/png;base64,2i3u\")\n\nExports an image from window to filename of the format specified by imageDataUri. \n\nRequired Arguments\n\nwindow: the window whose current state should be exported. This is returned by render().\nfilename: path to the file to be saved.\nwidth: width of the exported image, in pixels.\nheight: height of the exported image, in pixels.\nimageDataUri = \"data:image/png;base64,2i3u\": export image data uri.\n\n\n\n\n\n","category":"function"},{"location":"reference/#KeplerGLData","page":"Type & Function Reference","title":"KeplerGLData","text":"","category":"section"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.AbstractKeplerGLData","category":"page"},{"location":"reference/#KeplerGL.AbstractKeplerGLData","page":"Type & Function Reference","title":"KeplerGL.AbstractKeplerGLData","text":"abstract type AbstractKeplerGLData end\n\nAbstract type for datasets.\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.FieldsRowsData","category":"page"},{"location":"reference/#KeplerGL.FieldsRowsData","page":"Type & Function Reference","title":"KeplerGL.FieldsRowsData","text":"struct FieldsRowsData <: AbstractKeplerGLData\n    id::String\n    json::String\nend\n\nConcrete type for AbstractKeplerGLData, which contains  data in the fields-rows format that Kepler.gl uses natively. Used for data  that is loaded from KeplerGL maps in JSON format.\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.GeoJSONData","category":"page"},{"location":"reference/#KeplerGL.GeoJSONData","page":"Type & Function Reference","title":"KeplerGL.GeoJSONData","text":"struct GeoJSONData <: AbstractKeplerGLData\n    id::String\n    json::String\nend\n\nConcrete type for AbstractKeplerGLData, which contains  data in GeoJSON format.\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"Type & Function Reference","title":"Type & Function Reference","text":"KeplerGL.CSVData","category":"page"},{"location":"reference/#KeplerGL.CSVData","page":"Type & Function Reference","title":"KeplerGL.CSVData","text":"struct CSVData <: AbstractKeplerGLData\n    id::String\n    csvstring::String\nend\n\nConcrete type for AbstractKeplerGLData, which contains  data in CSV format. Used also when bringing data in via a DataFrame.\n\n\n\n\n\n","category":"type"},{"location":"#KeplerGL.jl","page":"Introduction","title":"KeplerGL.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package provides functions for displaying and exporting interactive maps through the Javascript package Kepler.gl, which is being loaded in Julia through Blink.jl. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The version of Kepler.gl that is currently used is 2.5.5.","category":"page"},{"location":"#Table-of-Contents","page":"Introduction","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\", \"layers.md\", \"examples.md\", \"reference.md\", \"ind.md\"]\nDepth = 3","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To install the package, type in the Julia command prompt","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add https://github.com/jmboehm/KeplerGL.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The package will be registered in Julia's General registry once it's a bit more mature.","category":"page"},{"location":"#Support-policy","page":"Introduction","title":"Support policy","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The development of the package is done in the author's spare time. I try to fix bugs as I have time and as they are reported on the Github issue tracker. The package isn't particularly complicated, and I'm happy to review and merge pull requests for both bug fixes and new features. Please don't email me about the package.","category":"page"},{"location":"#Package-philosophy","page":"Introduction","title":"Package philosophy","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are several excellent options for plotting maps using Julia (including GeoMakie.jl and Tyler.jl).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The main motivation behind creating this package is to tap into Kepler.gl's ease of use and bring it to scientific applications. Kepler.gl is excellent for creating beautiful maps interactively, but the resulting maps are difficult to integrate into a scientific workflow, which requires the maps to be created from code in order to be reproducible. This package aims to fill this gap.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Some principles I had in mind when creating the package:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Provide code interfaces for the creation of map layers with all options that Kepler.gl itself supports. \nThe way maps are stored internally follows the same structure as Kepler.gl's JSON format, this makes for easy saving and loading.\nThe keyword arguments in the layer functions should be named as close as possible to the layer options that Kepler.gl uses internally, except when ambiguous.","category":"page"},{"location":"#Roadmap","page":"Introduction","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Finish support for all layer types implemented in Kepler.gl.\nFilters, tooltips, legends, base maps\nMore and better data import options\nMore and better map export options\nUpdate to Kepler.gl 3.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Things that could be added, but are not currently planned, are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Compatibility with other WebIO backends\nCompatibility with GeoInterface.jl\nCompatibility with different tile providers\nFunctions to generate KeplerGL.jl map creation code from an open map window","category":"page"}]
}
